<!DOCTYPE html>
<html>
<head>
<title>README</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* html-md-01.css */

div#TOC li {
  list-style-type: none;
  list-style-position: outside;
  list-style-image: none;
  background-image: none;
  background-position: 0px center;
}

.navbar-brand, .navbar-fixed-bottom .navbar-collapse, .navbar-fixed-top .navbar-collapse, .pre-scrollable {
  font-family: Arial, Helvetica, sans-serif;
  font-size: 18px;
  font-weight: normal;
}

/*exercise*/
body, td {
   font-family: Times, TimesNewRoman, serif;
   background-color: white;
   font-size: 16px;
   width:  940px;
   margin: 30px;
   right:  860px;
   text-align:justify;
}

/*/*web page*/
body, td {
  font-family: Times, TimesNewRoman, serif;
  background-color: white;
  font-size: 16px;
  font-weight: normal;
}*/

/*exercise*/
tt, code, pre {
   font-family: Consolas, "Courier New", Monaco, monospace;
   font-size: 13px;
   font-weight: bolder;
}

/*web page*/
tt, code, pre {
  font-family: "Consolas", "Courier New", Monaco, monospace;
  font-size: 13px;
  font-weight: bold;
}

h1 {
  font-family: "Times New Roman", Times, serif;
  font-size: 24px;
  font-weight: normal;
}

h1.title {
  font-family: Arial, Helvetica, sans-serif;
  font-size: 26px;
  font-weight: normal;
}

h2 {
  font-family: "Times New Roman", Times, serif;
  font-size: 20px;
  font-weight: normal;
}

h3 {
  font-family: "Times New Roman", Times, serif;
  font-size: 20px;
  font-weight: normal;
  font-style: italic;
}

h4 {
  font-family: "Times New Roman", Times, serif;
  font-size: 18px;
  font-weight: bold;
}

h5 {
  font-family: "Times New Roman", Times, serif;
  font-size: 18px;
  font-weight: bold;
  font-style: italic;
}

h6 {
  font-family: "Times New Roman", Times, serif;
  font-size: 16px;
  font-weight: bolder;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre { 
   margin-top: 0;
   max-width: 100%;
   border: 1px solid #999999;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.2em;
   background-color:  #E0E0E0;
}

code.r, code.noeval, code.cpp {
   background-color: #eeeeee;
}

table, td, th {
  border: none;
}

blockquote {
   color:#000000;
   margin:0;
   padding-left: 1em;
   padding-right: 1em;
   border-left: 0.5em #E0E0E0 solid;
   border-right: 0.5em #E0E0E0 solid
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
  * {
    background-color: transparent !important;
    background-image: none !important;
    background-repeat: repeat !important;
    background-attachment: scroll !important;
    background-position: 0% 0% !important;
    color: black !important;
    filter: none !important;
  }
  body, td {
    font-family: Times, TimesNewRoman, serif;
    background-color: white;
    font-size: 11px;
    font-weight: normal;
    text-align:justify;
    width: 700px;
  }
  h1 {
    font-family: "Times New Roman", Times, serif;
    font-size: 18px;
    font-weight: normal;
  }
  h1.title {
    font-family: Arial, Helvetica, sans-serif;
    font-size: 18px;
    font-weight: normal;
  }
  h2 {
    font-family: "Times New Roman", Times, serif;
    font-size: 16px;
    font-weight: normal;
  }
  h3 {
    font-family: "Times New Roman", Times, serif;
    font-size: 16px;
    font-weight: normal;
    font-style: italic;
  }
  h4 {
    font-family: "Times New Roman", Times, serif;
    font-size: 14px;
    font-weight: bold;
  }
  h5 {
    font-family: "Times New Roman", Times, serif;
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
  }
  h6 {
    font-family: "Times New Roman", Times, serif;
    font-size: 12px;
    font-weight: bolder;
  }
  tt, code, pre {
    font-family: "Consolas", "Courier New", Monaco, monospace;
    font-size: 10px;
    font-weight: bold;
  }

   img {
      max-width: 100% !important;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}

</style>
</head>
<body>
<h1>mp-interp</h1>
<h2>Mean-preserving interpolation</h2>
<p>This repository contains Fortran 90/95 code that implements four approaches for mean-preserving interpolation as might be applied, for example, to the interpolation of pseudo-daily values from monthly means, that when averaged, reproduce those monthly means.  (The often-used linear interpolation approach does not do so.)  The four methods implemented here include those by:</p>
<ul>
<li>Epstein, E.S. (1991), On obtaining daily climatological values from monthly means, <em>J. Climate</em> 4:365-368;  </li>
<li>Harzallah, A. (1995) The interpolation of data series using a constrained iterating technique, <em>Monthly Weather Review</em> 123:2251-2254;</li>
<li>Killworth, P.D. (1996) Time interpolation of forcing fields in ocean models, <em>J. Physical Oceanography</em> 26:136-143; and</li>
<li>Rymes, M.D. and D.R. Meyers (2001) Mean preserving algorithm for smoothly interpolating averaged data, <em>Solar Energy</em> 71:225-231.</li>
</ul>
<p>In the discussion here, the example cases are considered to be single- or multiple-year time series of monthly data, from which we seek mean-preserving daily values, i.e. daily values that when averaged (or accumulated) over a particular month yield a mean value equal to the monthly input data, something that in general simple linear interpolation does not provide.  The approaches can be generalized to other situations if we regard the individual years as &quot;outer intervals&quot;, the months as &quot;inner intervals&quot;, and the days as &quot;subintervals,&quot; for which interpolated values are sought.  For example, the Harzallah (1991) approach was illustrated using a time series of annual values (inner itervals, in this case), from which interpolated monthly subinterval values that preserved the annual means were sought.  </p>
<p>The Epstein (1991) approach is based on a harmonic analysis (or harmonic regression) of, for example, a year's worth of monthly mean &quot;control&quot; values, where the basic harmonic analysis is recast as the integration of the control values over the year; this assures preservation of the interpolated values.  The function fit to the control data is then evaluated at &quot;target&quot; subinterval (e.g. daily) values.  The method is periodic, in the sense that the curve defined by the interpolated daily values &quot;wraps around&quot;.  It is calculated directly; no iterative fitting or improvement is involved.  Like all of these methods, it is prone to &quot;overshooting&quot; (which, in practice, is a necessary feature (as opposed to problem) for reproducing the means).  Because it is applied a year at a time, when applied to a time series of many years of monthly data, small discontinuities in the interpolated daily data will occur between years.  In the implementation here, these are &quot;fixed&quot; by smoothing the interpolated daily over the end of one year and beginning of the following year.</p>
<p>The Harzallah (1995) approach involves fitting a spline to the control (e.g. monthly) data, and evaluating the spline at target (e.g. daily) values.  Interpolated daily values using the initial spline fit are not necessarily mean preserving.  The method involves finding the &quot;residuals&quot; between the initial (e.g. monthly) means and the means of the interpolated (e.g. daily) values, and fitting a second spline to those values.  This procedure is repeated until the residuals are acceptably small, and then the interpolated values for a particular &quot;target&quot; day are taken as the sum of the interpolated values across iterations.  The method is not periodic, but can be made so by padding the beginning and end of a year with data from the end and beginning of the year, respectively.  Year-to-year continuity can be had by padding the beginning of any particular year with data from the end of the previous year, and padding the end with data from the next year.  Harzallah used natural cubic splines, and additional spline-fitting methods are implemented here (e.g. Akima's method and a piecewise-cubic Hermite spline). </p>
<p>The Killworth (1996) approach is a direct, as opposed to iterative approach, and is also non periodic. It uses linear interpolation, applied to a set of &quot;adjusted&quot; (or &quot;pseudodata&quot;) control values, that when interpolated, produce values that preserve the means of the original control data.  The adjustment is made by inverting a tridiagonal matrix (with elements chosen to smooth the data), and postmultiplying it by the original control-data vector to yield the adjusted control data.  The interpolated values form linear seqments, which relative to the other approaches may seem too unrealistic.  Like the Harzallah approach, the Killowrth approach can be made periodic via padding.</p>
<p>The Rymes and Meyers (2001) approach involves iteratively &quot;correcting&quot; a initial set of interpolated values for each &quot;subinterval&quot; (e.g. day).  Their approach is unique, it that it allows for the imposition of upper and lower bounds for the interpolated values, which avoids strong-arm corrections of interpolated values for variables like precipitation, which should not be negative.  The number of iterations required may be quite large, but the number can be substantially reduced by beginning with initial linearly interpolated values.</p>
<p>All of these methods are related to some extent.  For example, the updating equation (eqn. 3) in Rymes and Meyer <sub><sub>n</sub></sub><strong>m</strong><sub>new<sub>1</sub></sub> = <sub><sub>n</sub></sub><strong>A<strong><sub><sub>n</sub></sub></strong>m</strong><sub>old<sub>1</sub></sub> resembles eqn 4 in Killworth, <sub><sub>n</sub></sub><strong>A</strong><sub><sub>n</sub></sub><strong>d'<strong><sub><sub>1</sub></sub> = <sub><sub>n</sub></sub></strong>d<strong><sub><sub>1</sub></sub>, and it also the case that cubic splines (as in Harzallah) can be fit by solving an equation like <sub><sub>n</sub></sub><strong>A</strong><sub><sub>n</sub></sub></strong>x<strong><sub><sub>n</sub></sub> = <sub><sub>n</sub></sub></strong>b</strong><sub><sub>1</sub></sub> for <strong>x</strong>.  (In each case, <strong>A</strong> is a tridiagonal matrix.). What differs among the methods is the iterative refinement of the interpolated values.</p>
<h2>Fortran implementation</h2>
<p>The approaches are implemented here as modules that contain a subroutine that manages the application of the specific algorithms to series of, for example, years, which are referred to here as &quot;outer intervals&quot;.  For each outer interval, the subroutine collects the appropriate &quot;inner interval&quot; (e.g. monthly) data, along with the number of &quot;subinterals&quot; or target points for which interpolated data are desired.  These data are then passed to another subroutine that gets the interpolated values for the outer interval.  These modules are named <code>mp_interp_epstein_subs.f90</code>, <code>mp_interp_harzallah_subs.f90</code>,  <code>mp_interp_killworth_subs.f90</code>, and <code>mp_interp_rymes_and_meyer_subs.f90</code>, respectively.</p>
<p>There is a module of utility subroutines, including one called <code>enforce_mean()</code>.  None of the approaches are <em>exactly</em> mean-preserving.  The Harzallah (1991) and Rymes and Meyer (2001) approaches are iterative, and only approach mean-preserving using a reasonable number of iterations.  At first glance, the Epstein (1991) approach should be, but the algorithm was derived assuming that the inner intervals (e.g. months) are all of the same length.  In the Killworth (1996) approach, rounding errors in the matrix inversion contribute to inexact matching of the means.  In the Epstein (1991) and Killworth (1996) approaches, the differences between the control means and those calculated using the interpolated data are very small.  All of the approaches have problems with variables like precipitation, which must be non-negative.  In the applications here, negative interpolated values are simply set to zero.  The role of the <code>enforce_mean()</code> subroutine is to adjust the subinterval interpolated values so that they match their respective inner-interval value.  This is done by simply apportioning the difference across the (non-zero) subinterval values.  In practice this could lead to small month-to-month discontinuities among the daily values, but these are not really noticeable.</p>
<p>The Harzallah (1995) and Killworth (1996) approaches require some external (to the code here) procedures.  The Harzallah approach requires a spline-fitting routine, and the method has been tested with three: 1) a cubic spline implemented by John Burkhardt (https://people.sc.fsu.edu/~jburkardt/f_src/spline/spline.html, last accessed 8 Dec 2020), 2) a piecewise cubic Hermite spline also implemented by Burkhardt (in the same collection), and 3) Akima's method (akima697, https://calgo.acm.org/, last accessed 8 Dec 2020).  Harzallah's approach was developed using cubic splines, but the piece-wise cubic Hermite spline, which enforces monotonicity of the interpolated values between control points, seems to produce less-dramatic &quot;overshoots&quot;.  Akima's method looks like compromise between the two.</p>
<p>KIllworth's (1996) method requires a matrix-inversion subroutine.  Here the functions DGETRF(), and DGETRI() from the lapack95 library were used.  </p>
<h2>Testing</h2>
<p>The four approaches were tested by attempting to reproduce some of the figures in the original articles. Figure 1 in Epstein (1991), Fig. 2 in Harzallah (1995), Fig. 5a in Killworth (1996), and Figs. 4 and 5 in Rymes and Meyers (2001) were extracted from .pdfs of the articles, and the mean inner-interval values (i.e. annual values in Harzallah (1995), monthly values in the others) were digitized.  These values are shown in blue in the figures in the folder <code>/test_methods/plots/</code>.  The interpolated subinterval values are shown by small red dots, and the inner-interval means ofthose values are shown by larger red dots.  The differences between the published examples and their reproduction here are small, and probably related to the digitization.</p>
<h2>Comparison of the approaches</h2>
<p>The four applroaches were compared using &quot;observed&quot; daily and monthly-mean data for a twenty-year period (1997-2016) drawn from the NCEP-DOE Reanalysis 2 (https://www.psl.noaa.gov/data/gridded/data.ncep.reanalysis2.html).  Two variables were used, near-surface (2 m) air temperature (e.g. <code>air.2m.gauss.*year*.nc</code>, where <code>*year*</code> is replaced by an appropriate value), also known as <em>tas</em>, and precipitation rate (e.g. <code>prate.sfc,gauss.*year*.nc</code>), also known as <em>pr</em>.  Two gridpoints were selected, one from a region with a Mediterranean-like climate (California, 238.75&deg;E, 38.75&deg;N) and West Africa (3.75&deg;E, 8.75&deg;N), to represent two instances of high seasonal contrast in precipitation with many daily zeros, which might be expected to produce problems for mean-preserving interpolation.  The input data, both daily and monthly, are in the folder <code>/data/surce/</code>, and the output data used to construct the figures are in `/data/interp/'.</p>
<p>The folder <code>/figs</code> contains a set of 16 plots, one for each method, variable and region, plus a set of four summary plots showing all methods for each variable and region.  Each figure shows data for the full twenty-year period, plus a five-year period blown up to show more detail.  The original daily values are plotted in the background in gray in each figure.  For the sixteen method by variable by region plots (e.g. <code>epstein_tas_monsoon.pdf</code>, the input monthly mean data, formed by averaging the daily data, are plotted in two ways, as a step-plot (in black), and as black dot at midpoint of each month.  The interpolated (pseudo-) daily data are plotted in blue, and the monthly means of the interpolated in red.  Owing to the application of the <code>enforce_mean()</code> subroutine, the black and red dots can be seen to be coincident.  
</p>
<p>There are some subtle differences among the approaches that can be seen in the comparison plots (e.g. <code>pr_med.pdf</code>):  1) the Epstien approach appears to produce the greatest amount of overshooting, but even so, it is not astonishing.  The Rhymes and Meyers approach appears to procduce the least amount of overshooting, but take about twice as long as the others to execute.  The Killworth approach, as mentioned previous, produces straight-line segments with abrupt changes in slope, which may in some contexts be regarded as too unrealistic.  The Harzallah approach (in purple on the four comparison plots) appears to be a &quot;middle-of-the-road&quot; choice, with modest overshoots, and also a fast execution time.</p>
<p>Overall, there is more similarity than difference among the approaches; all produce satisfactory results.  It should be noted, howver that none of the approaches produce pseudo-daily values that &quot;look&quot; like the obseved daily values -- the interpolation methods are not &quot;weather generators&quot;, but instead simply perform the taks of producing daily inerpolated values that preserve the monthly mean values they are derived from.</p>
<h2>Programs</h2>
<p>The modules can be found in the folder <code>/f90/modules/</code>, and demonstation programs for producing the results described below can e found in the folder <code>/f90/demo_programs/</code>.  The program <code>test_epstein.f90</code>, for example, was used to regeneratre Fig. 1 in Epstein (1991), the program <code>demo_ts_epstein.f90</code> was used to generate the data for the comparison figures, and the program <code>demo_1yr_epstein.f90</code> produces simple output at the console for a single year of data.</p>
<p>The programs were run on Windows 10, using the Intel Fortran Compiler version 19.1 in the Microsoft Visual Studio Community 2019 development environment, and on MacOS Catalina using the gcc gfortran compiler version 10.2.0, in the Eclipse for Scientific Computing IDE version 2020-09 (4.17.0).  
</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
